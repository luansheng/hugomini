---
title: 选择指数制定中的加权值计算基础知识
author: Package Build
date: '2025-09-14'
slug: calculating-weights-in-selection-index
categories:
  - 数量遗传学
tags:
  - weight
  - selection index
---



<div id="目的" class="section level2">
<h2>目的</h2>
<p>理解smith-hazel公式，求导性状加权值的原理。</p>
<p>核心公式如下：</p>
<p><span class="math display">\[
\begin{align*}
P=Var(x) \\
G=Cov(x,g) \\
Pb=Ga \\
\end{align*}
\]</span></p>
<p>其中<span class="math inline">\(P\)</span>为表型方差-协方差矩阵；G为表型与育种值的遗传协方差矩阵，常用<span class="math inline">\(G_{A}\)</span> 也就是加性遗传方差-协方差矩阵代替 <span class="math inline">\(G\)</span>；a通常为经济加权或者相对经济重要性；b为我们要获得的加权值，通过以下公式获得：</p>
<p><span class="math display">\[
b=P^{-1}Ga
\]</span></p>
<p>这就是Smith-Hazel的核心公式。它自动考虑了性状间的<strong>尺度差异</strong>（P）和<strong>遗传关联（G）</strong>。</p>
<p>上述公式求导出来的b，主要是结合表型使用的。当前，利用ASReml等软件，通常可以获得EBV。因此，当x是EBV时，公式可以近似写为：</p>
<p><span class="math display">\[
b=G^{-1}_{A}a
\]</span></p>
<p>略微理解了，后续有时间再补充。</p>
</div>
<div id="迷你的小例子" class="section level2">
<h2>迷你的小例子</h2>
<p>手动计算加权。首先给出体重BW和出肉率MY两个性状的遗传力，遗传相关，表型标准差。</p>
<pre class="r"><code>## --- 输入参数 ---
h2_BW &lt;- 0.47; h2_MY &lt;- 0.47
rg     &lt;- 0.41
sdP_BW &lt;- 4.13; sdP_MY &lt;- 0.02   # 若有真实表型SD，用真实值替换</code></pre>
<p>生成P、G矩阵</p>
<pre class="r"><code>## --- 构造 GA ---
VA_BW &lt;- h2_BW * sdP_BW^2
VA_MY &lt;- h2_MY * sdP_MY^2
COV_A &lt;- rg * sqrt(VA_BW * VA_MY)
GA &lt;- matrix(c(VA_BW, COV_A,
               COV_A, VA_MY), 2, 2,
             dimnames = list(c(&quot;BW&quot;,&quot;MY&quot;), c(&quot;BW&quot;,&quot;MY&quot;)))</code></pre>
<p>设置求解b的函数solve_index()。这个函数的参数包括GA矩阵、经济加权a，选择强度i。这里的选择强度，主要是用来评估预期遗传进展。</p>
<pre class="r"><code>## 工具函数：给定 a 计算 b，并给出期望响应
solve_index &lt;- function(GA, a, i = 1.755) {
  b &lt;- solve(GA, a)                 # w ∝ GA^{-1} a
  b &lt;- as.numeric(b / sum(b))       # 归一化到和=1（不改排序）
  sdI &lt;- sqrt(drop(t(b) %*% GA %*% b))
  Delta &lt;- as.numeric(i * (GA %*% b) / sdI)  # 每个性状的期望遗传响应（标准化单位）
  names(b) &lt;- rownames(GA); names(Delta) &lt;- rownames(GA)
  list(b = b, sdI = sdI, Delta = Delta)
}</code></pre>
<p>首先考虑一个等权重的情况：</p>
<pre class="r"><code>## --- 情形A：等重 a=(1,1) ---
res_equal &lt;- solve_index(GA, a = c(1,1))
res_equal$b      </code></pre>
<pre><code>##           BW           MY 
## -0.001969797  1.001969797</code></pre>
<pre class="r"><code>res_equal$Delta  </code></pre>
<pre><code>##         BW         MY 
## 0.02199128 0.02199128</code></pre>
<p>再考虑一个出肉率权重更高的情况：</p>
<pre class="r"><code>## --- 情形B：偏重MY a=(1,1.5) ---
res_MYhi &lt;- solve_index(GA, a = c(1,1.5))
res_MYhi$b     </code></pre>
<pre><code>##           BW           MY 
## -0.001976347  1.001976347</code></pre>
<pre class="r"><code>res_MYhi$Delta </code></pre>
<pre><code>##         BW         MY 
## 0.01465122 0.02197683</code></pre>
</div>
<div id="alphasimr中的smith-hazel实现" class="section level2">
<h2>AlphaSimR中的Smith-Hazel实现</h2>
<p>AlphaSimR中有一个Smith-Hazel函数。</p>
<p>构建一个基础群体的单倍型，包括10个个体，1条染色体，10个QTL标记。</p>
<pre class="r"><code># 基础群体
library(AlphaSimR)</code></pre>
<pre><code>## Loading required package: R6</code></pre>
<pre class="r"><code>founderPop = quickHaplo(nInd = 10, nChr = 1, segSites = 10)</code></pre>
<p>设置模拟参数</p>
<pre class="r"><code>SP = SimParam$new(founderPop)</code></pre>
<p>模拟两个性状，包括遗传相关矩阵等。性状间是负相关：-0.5。diag生成一个对角线为1的矩阵。</p>
<p>addTraitA() 这个函数只考虑加性效应，<strong>Additive</strong>的意思。接受性状的参数。</p>
<p>setVarE() 设置性状的遗传力均为0.5</p>
<pre class="r"><code>G = 1.5 * diag(2)-0.5
SP$addTraitA(10, mean = c(0,0), var = c(1, 1), corA = G)
SP$setVarE(h2=c(0.5, 0.5))</code></pre>
<p>利用基础群体和设置的相关参数，创建育种群体</p>
<pre class="r"><code>pop= newPop(founderPop, simParam = SP)</code></pre>
<p>计算Smith-Hazel 权重</p>
<pre class="r"><code>econWt = c(1, 1)
b = smithHazel(econWt, varG(pop), varP(pop))
b</code></pre>
<pre><code>##             [,1]
## Trait1 0.8335625
## Trait2 0.6643207</code></pre>
<p>然后根据新的权重b，计算选择指数，选择优秀个体</p>
<pre class="r"><code>pop2= selectInd(pop, nInd = 2, trait = selIndex, simParam = SP, b=b)
pop2</code></pre>
<pre><code>## An object of class &quot;Pop&quot; 
## Ploidy: 2 
## Individuals: 2 
## Chromosomes: 1 
## Loci: 10 
## Traits: 2</code></pre>
</div>
